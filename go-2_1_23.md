# Go 1.23 Developer Pocketbook / Cheatsheet

> Concise, idiomatic, and production-ready reference for Go (latest
> stable: **1.23**).\
> Reading time: \~40 minutes.\
> Sources: [Official Go Docs](https://go.dev/doc/), [Effective
> Go](https://go.dev/doc/effective_go), [Go
> Wiki](https://github.com/golang/go/wiki).

------------------------------------------------------------------------

# ðŸ“‘ Table of Contents

1.  [Overview](#overview)
2.  [Setup](#setup)
3.  [Fundamentals](#fundamentals)
4.  [Data Structures](#data-structures)
5.  [Functions & Paradigm](#functions--paradigm)
6.  [Error Handling & Debugging](#error-handling--debugging)
7.  [Code Organization](#code-organization)
8.  [Complete Example Program](#complete-example-program)
9.  [Best Practices](#best-practices)
10. [Quick Reference](#quick-reference)

------------------------------------------------------------------------

## 1. Overview

-   **Language**: Go 1.23 (compiled, statically typed,
    garbage-collected).\
-   **Paradigm**: Concurrent, imperative, structural typing, composition
    over inheritance.\
-   **Philosophy**: *Simplicity, readability, productivity at scale.*\
-   **Use cases**: Cloud-native, microservices, CLI tools, DevOps,
    networking, distributed systems.\
-   **Learning curve**: Steep at first (strict typing, concurrency),
    smooth after basics.

------------------------------------------------------------------------

## 2. Setup

### Install

``` sh
# macOS / Linux
brew install go

# Windows (scoop)
scoop install go

# Verify
go version
```

### Package Management

``` sh
go mod init myapp   # Initialize module
go get pkg@latest   # Add dependency
go build            # Compile
go run main.go      # Run program
go test ./...       # Run tests
go install ./...    # Install binary to $GOBIN
```

### Recommended Tools

-   **Editor**: VS Code (+ Go extension), Goland.\
-   **Linters**: `golangci-lint`.\
-   **Formatter**: `gofmt`, `goimports`.

------------------------------------------------------------------------

## 3. Fundamentals

### Variables & Constants

``` go
var x int = 42
y := 99          // short declaration
const Pi = 3.14
```

### Data Types

-   **Primitives**: `int`, `float64`, `string`, `bool`.\
-   **Collections**: `array`, `slice`, `map`.\
-   **Others**: `struct`, `interface`, `chan`.

``` go
s := []string{"go", "is", "fun"}
m := map[string]int{"a":1, "b":2}
```

### Type Conversion

``` go
i := int64(42)
f := float64(i)
```

### Control Flow

``` go
if x > 0 { ... }
for i := 0; i < 5; i++ { ... }
for _, v := range s { ... }

switch day {
case "Mon": fmt.Println("Start")
default: fmt.Println("Other")
}
```

### I/O

``` go
fmt.Println("Hello")
data, _ := os.ReadFile("file.txt")
os.WriteFile("out.txt", data, 0644)
```

------------------------------------------------------------------------

## 4. Data Structures

### Arrays & Slices

``` go
arr := [3]int{1,2,3}
s := []int{1,2,3}
s = append(s, 4)
```

### Maps

``` go
m := map[string]int{"a":1}
m["b"] = 2
delete(m, "a")
```

### Structs

``` go
type User struct {
  ID int
  Name string
}
u := User{1, "Bob"}
```

### Interfaces

``` go
type Stringer interface {
  String() string
}
```

------------------------------------------------------------------------

## 5. Functions & Paradigm

### Functions

``` go
func add(a, b int) int { return a+b }
```

### Multiple Returns

``` go
func div(a, b int) (int, error) {
  if b == 0 { return 0, fmt.Errorf("div by zero") }
  return a/b, nil
}
```

### Closures

``` go
func counter() func() int {
  x := 0
  return func() int { x++; return x }
}
```

### Generics

``` go
func Max[T comparable](a, b T) T {
  if a > b { return a }
  return b
}
```

### Concurrency

``` go
ch := make(chan int)
go func() { ch <- 42 }()
fmt.Println(<-ch)
```

------------------------------------------------------------------------

## 6. Error Handling & Debugging

### Idiomatic Errors

``` go
val, err := div(4,0)
if err != nil {
  log.Fatal(err)
}
```

### Logging

``` go
log.Println("info")
log.Fatalf("fatal: %v", err)
```

### Testing

``` go
import "testing"

func TestAdd(t *testing.T) {
  got := add(2,3)
  if got != 5 {
    t.Errorf("expected 5, got %d", got)
  }
}
```

Run: `go test ./...`

------------------------------------------------------------------------

## 7. Code Organization

-   **Modules**: Root-level `go.mod`.\
-   **Packages**: Directory = package. `main` is entrypoint.\
-   **Imports**: Avoid cycles.\
-   **Layout**:
    [golang-standards/project-layout](https://github.com/golang-standards/project-layout).

``` sh
myapp/
  cmd/myapp/main.go
  internal/
  pkg/
```

------------------------------------------------------------------------

## 8. Complete Example Program

### Task Manager CLI

`main.go`:

``` go
package main

import (
  "bufio"
  "encoding/json"
  "fmt"
  "os"
  "strings"
)

type Task struct {
  ID int
  Title string
  Priority int
  Done bool
}

var tasks []Task
const file = "tasks.json"

func save() error {
  data, err := json.MarshalIndent(tasks, "", "  ")
  if err != nil { return err }
  return os.WriteFile(file, data, 0644)
}

func load() {
  data, err := os.ReadFile(file)
  if err == nil { json.Unmarshal(data, &tasks) }
}

func addTask(title string, priority int) {
  t := Task{ID: len(tasks)+1, Title: title, Priority: priority}
  tasks = append(tasks, t)
  save()
}

func listTasks() {
  for _, t := range tasks {
    status := " "
    if t.Done { status = "x" }
    fmt.Printf("[%s] #%d %s (p%d)\n", status, t.ID, t.Title, t.Priority)
  }
}

func completeTask(id int) {
  for i := range tasks {
    if tasks[i].ID == id {
      tasks[i].Done = true
      save()
    }
  }
}

func main() {
  load()
  scanner := bufio.NewScanner(os.Stdin)
  fmt.Println("Task Manager (add/list/done/exit)")
  for {
    fmt.Print("> ")
    scanner.Scan()
    parts := strings.Fields(scanner.Text())
    if len(parts)==0 { continue }
    switch parts[0] {
    case "add":
      if len(parts) < 3 { fmt.Println("usage: add <title> <priority>"); continue }
      title := parts[1]
      var p int; fmt.Sscan(parts[2], &p)
      addTask(title, p)
    case "list":
      listTasks()
    case "done":
      var id int; fmt.Sscan(parts[1], &id)
      completeTask(id)
    case "exit":
      return
    }
  }
}
```

`main_test.go`:

``` go
package main

import "testing"

func TestAddTask(t *testing.T) {
  tasks = nil
  addTask("Test", 1)
  if len(tasks) != 1 || tasks[0].Title != "Test" {
    t.Fatal("task not added")
  }
}
```

Run:

``` sh
go run main.go
go test
```

------------------------------------------------------------------------

## 9. Best Practices

-   **Formatting**: Always `gofmt`.\
-   **Error handling**: Check errors, avoid panic in production.\
-   **Concurrency**: Prefer channels over shared state.\
-   **Performance**: Preallocate slices, avoid unnecessary goroutines.\
-   **Security**: Validate input, avoid unsafe.\
-   **Popular Libs**:
    -   Web: [gin](https://github.com/gin-gonic/gin)\
    -   CLI: [cobra](https://github.com/spf13/cobra)\
    -   Config: [viper](https://github.com/spf13/viper)

------------------------------------------------------------------------

## 10. Quick Reference

### Syntax

``` go
// Declaration
var x int
x := 10

// Constants
const Pi = 3.14

// Functions
func f(a int) int { return a }

// Struct & Methods
type T struct { X int }
func (t T) GetX() int { return t.X }
```

### CLI

``` sh
go build
go run main.go
go test ./...
go fmt ./...
go mod tidy
```

### Standard Library Highlights

-   `fmt`, `os`, `io`, `bufio`, `net/http`, `time`, `context`, `sync`,
    `encoding/json`.

------------------------------------------------------------------------

âœ… You now have the **ultimate Go 1.23 pocketbook**.
