# PHP 8.4 — Developer Pocketbook / Cheatsheet

> **Brilliant, compact, production-ready** pocketbook for PHP 8.4 — one-file Markdown you can keep open while coding.

**Reading time:** ~30–45 minutes

---

## Table of Contents
1. [Overview](#overview)
2. [Setup](#setup)
3. [Fundamentals](#fundamentals)
4. [Data Structures](#data-structures)
5. [Functions & Paradigms](#functions--paradigms)
6. [Error Handling & Debugging](#error-handling--debugging)
7. [Code Organization](#code-organization)
8. [Complete Example — Task Manager CLI](#complete-example--task-manager-cli)
9. [Best Practices](#best-practices)
10. [Quick Reference](#quick-reference)
11. [Further Reading](#further-reading)

---

# Overview

**PHP 8.4** — multi-paradigm language (imperative, OO, functional styles), optimized for web & CLI. Focus: developer ergonomics, JIT improvements, typed properties, union types, and modern standardization (PSR).

**Main use cases:** web backends (frameworks: Laravel, Symfony), APIs, CLI tooling, small services, templating, and scripting.

**Learning curve:** gentle for beginners (simple start with `<?php`), deep when adopting strict typing, dependency injection, and modern architecture.

---

# Setup

## Install & run basics

- Check installed version: ``php -v``
- Run file: ``php script.php``
- Interactive REPL: ``php -a``
- Create CLI binary script: shebang `#!/usr/bin/env php` + `chmod +x bin/cli`

## Package manager — Composer

- Install composer (system-specific). Basic commands:
  - `composer init` — create composer.json
  - `composer require vendor/package` — add dependency
  - `composer install` — install from composer.lock
  - `composer update` — update deps
  - Autoloading: `require 'vendor/autoload.php';`

## Recommended editors & extensions

- VS Code + PHP Intelephense, PHPStan extension, phpcs, PHP Debug (Xdebug)
- PhpStorm (excellent built-in support)
- CLI tools: `phpunit` (testing), `phpstan` (static analysis), `psalm`, `composer`, `phpcs` (coding standard)

---

# Fundamentals

## PHP tags

```php
<?php
// Short echo: <?= "hello" ?>
```

## Variables & constants

- Variables: start with `$`, dynamically typed but can be strictly typed in functions/types.
- Constants: `const NAME = 'value';` (class-level) or `define('NAME', 'value');`

```php
$nu = 123;
const PI = 3.1415;
```

## Types & conversions

Primitive types: `int`, `float`, `string`, `bool`, `array`, `object`, `null`, `resource`

Union types and mixed:
```php
function f(int|float $x): int|float|null { /* ... */ }
```

### Casting & conversions
- `(int)$x`, `(string)$x`, `(bool)$x` — explicit casts.
- PHP performs weak coercion in many contexts; use strict checks `===` to avoid surprises.

## Operators

Arithmetic, comparison, logical operators, and newer `match` expression (PHP 8+):

```php
$x ??= 'default';        // null coalescing assignment
$y = $a <=> $b;          // spaceship operator
$result = match($status) { 'ok' => 200, default => 400 };
```

## Control Flow

- `if`, `elseif`, `else`
- `switch` and `match` (match is expression, strict comparison)
- Loops: `for`, `foreach`, `while`, `do-while`

```php
foreach ($items as $k => $v) {
    echo "$k -> $v\n";
}
```

## Console & File I/O

Read STDIN:
```php
$line = trim(fgets(STDIN));
```
Write to STDOUT/STDERR:
```php
fwrite(STDOUT, "ok\n");
fwrite(STDERR, "error\n");
```
File operations: `file_get_contents`, `file_put_contents`, `fopen/fwrite/fclose`.

---

# Data Structures

## Arrays

Arrays are ordered maps — can be used as lists or dictionaries.

```php
$list = [1,2,3];
$map = ['a' => 1, 'b' => 2];
array_push($list, 4);
```

Useful functions: `array_map`, `array_filter`, `array_reduce`, `array_key_exists`, `array_column`.

## Strings

String interpolation: `"Hello $name"` vs single quoted. Heredoc/Nowdoc for multi-line.

Useful functions: `strlen`, `substr`, `str_contains`, `str_starts_with`, `str_replace`, `preg_*` (regex).

## Spl data structures & objects

- `SplStack`, `SplQueue`, `SplPriorityQueue`, `Ds\Vector`, `Ds\Map` (if `ds` extension installed).
- Use `stdClass` or small value objects for structured records.

## Enums & Readonly (PHP 8.1+)

```php
enum Priority: string { case LOW = 'low'; case HIGH = 'high'; }
class Task { public readonly string $id; }
```

Idiomatic patterns: Favor small value objects and DTOs over bare arrays for complex data.

---

# Functions & Paradigms

## Function syntax

```php
function sum(int $a, int $b): int {
    return $a + $b;
}
```

Named arguments (PHP 8+): `func(a:1, b:2)`

## Closures & higher-order

```php
$adder = fn($x) => fn($y) => $x + $y; // arrow functions
$items = array_map(fn($v) => $v * 2, $items);
```

Closures can be bound with `use`:
```php
$prefix = 'x-';
$fn = function($s) use ($prefix) { return $prefix.$s; };
```

## OOP essentials

- Declaration: `class`, `interface`, `trait`.
- Visibility: `public`, `protected`, `private`.
- Constructor property promotion (PHP 8+):

```php
class User {
    public function __construct(private string $id, public string $name) {}
}
```

- Inheritance & final classes, abstract classes.
- `static` vs `self` vs `static::` late static binding.

## Generics & Templates

PHP lacks native generics; use docblock templates + static analysis (`phpstan`/`psalm`) to simulate generic typing.

## Concurrency

PHP itself is single-threaded per request; concurrency via:
- Async libraries (Swoole, ReactPHP)
- Process-based (pcntl, symfony/process)
- Queue systems (RabbitMQ, Redis queues)

---

# Error Handling & Debugging

## Exceptions & errors

- Use `\Throwable` / `\Exception` for error control.
- Catch specific exceptions and avoid catching `\Throwable` unless rethrowing.

```php
try {
    // risky
} catch (SpecificException $e) {
    // handle
} finally {
    // cleanup
}
```

## Error levels & conversion

- Convert errors to exceptions with `set_error_handler()` or `ErrorException` for unified handling.

## Logging & debugging

- Use PSR-3 compatible logger (Monolog).
- Use Xdebug for step-debugging and profiling.
- Use `var_export`, `print_r`, and `dd()` helpers (in dev only).

## Unit testing

- PHPUnit is the standard. Basic test:

```php
use PHPUnit\Framework\TestCase;
class TaskTest extends TestCase {
    public function testCreate() {
        $t = new Task('id','title');
        $this->assertEquals('title', $t->title);
    }
}
```

Run: `vendor/bin/phpunit` or `phpunit` via phar.

---

# Code Organization

## Namespaces & autoloading

- PSR-4 autoloading standard. composer.json example:

```json
{
  "autoload": {
    "psr-4": { "MyApp\\": "src/" }
  }
}
```

Use `namespace MyApp\Sub;` at top of PHP files.

## Dependency management

- Composer for third-party libraries.
- Lock dependencies with composer.lock for reproducible builds.

## Standard project layout (recommended)

```
project/
  src/
  tests/
  bin/
  composer.json
  phpunit.xml
  README.md
```

---

# Complete Example — Task Manager CLI

A small, idiomatic CLI task manager. Files are shown inline; keep as `src/` in real project.

### Usage

```
php bin/task list
php bin/task add "Buy milk" --priority=high
php bin/task done <id>
```

### Files

#### `composer.json` (excerpt)

```json
{
  "name": "example/task-cli",
  "require": {
    "php": "^8.1 || ^8.4",
    "symfony/console": "^6.0"
  },
  "autoload": { "psr-4": { "TaskCli\\": "src/" } }
}
```

#### `bin/task` (executable)

```php
#!/usr/bin/env php
<?php
require __DIR__ . '/../vendor/autoload.php';
use Symfony\Component\Console\Application;

$app = new Application('Task CLI', '0.1');
$app->add(new TaskCli\Command\ListCommand());
$app->add(new TaskCli\Command\AddCommand());
$app->add(new TaskCli\Command\DoneCommand());
$app->run();
```

#### `src/Model/Task.php`

```php
namespace TaskCli\Model;

enum Priority: string { case LOW = 'low'; case MEDIUM = 'med'; case HIGH = 'high'; }

final class Task
{
    public function __construct(
        public readonly string $id,
        public string $title,
        public Priority $priority = Priority::MEDIUM,
        public bool $done = false
    ) {}

    public static function fromArray(array $a): self {
        return new self($a['id'], $a['title'], Priority::from($a['priority'] ?? 'med'), $a['done'] ?? false);
    }

    public function toArray(): array {
        return ['id'=>$this->id,'title'=>$this->title,'priority'=>$this->priority->value,'done'=>$this->done];
    }
}
```

#### `src/Storage/FileStorage.php`

```php
namespace TaskCli\Storage;
use TaskCli\Model\Task;

final class FileStorage
{
    public function __construct(private string $path) {}

    /** @return Task[] */
    public function all(): array {
        if (!file_exists($this->path)) return [];
        $j = json_decode((string)file_get_contents($this->path), true);
        return array_map(fn($a)=>Task::fromArray($a), $j ?: []);
    }

    /** @param Task[] $tasks */
    public function save(array $tasks): void {
        $arr = array_map(fn(Task $t)=>$t->toArray(), $tasks);
        file_put_contents($this->path, json_encode($arr, JSON_PRETTY_PRINT));
    }
}
```

#### `src/Command/AddCommand.php` (simplified)

```php
namespace TaskCli\Command;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use TaskCli\Storage\FileStorage;
use TaskCli\Model\Task;

class AddCommand extends Command
{
    protected static $defaultName = 'add';
    protected function configure() {
        $this->addArgument('title', InputArgument::REQUIRED);
        $this->addOption('priority', null, InputOption::VALUE_REQUIRED, 'Priority', 'med');
    }
    protected function execute($input, $output) {
        $title = $input->getArgument('title');
        $priority = $input->getOption('priority');
        $storage = new FileStorage(__DIR__.'/../../data/tasks.json');
        $tasks = $storage->all();
        $task = new Task(bin2hex(random_bytes(4)), $title, Task::Priority::from($priority));
        $tasks[] = $task;
        $storage->save($tasks);
        $output->writeln("Added: {$task->id}");
        return Command::SUCCESS;
    }
}
```

> Note: The example uses Symfony Console to focus on command architecture; you can implement your own argument parsing.

### One PHPUnit test (basic)

`tests/TaskTest.php`

```php
use PHPUnit\Framework\TestCase;
use TaskCli\Model\Task;

class TaskTest extends TestCase {
    public function testToFromArray() {
        $t = new Task('abc','do things', Task::Priority::HIGH, false);
        $a = $t->toArray();
        $this->assertEquals('abc', $a['id']);
        $t2 = Task::fromArray($a);
        $this->assertEquals('do things', $t2->title);
    }
}
```

---

# Best Practices

- Follow PSR standards (PSR-12 code style, PSR-4 autoloading, PSR-3 logging, PSR-7 HTTP messages).
- Use typed properties & return types. Prefer strict comparisons (`===`).
- Prefer dependency injection over global state.
- For public packages, keep backward compatibility and semantic versioning.
- Validate input & sanitize output. Use prepared statements or an ORM to avoid SQL injection.
- Avoid premature optimization; measure with profiling (Xdebug, Blackfire).
- Secure secrets (use env vars, not committed files). Keep sensitive data out of logs.

---

# Quick Reference

## Common snippets

```php
// arrow fn
$dbl = fn($x) => $x*2;

// null coalesce
$value = $a['k'] ?? 'default';

// match
$result = match($code) { 200 => 'OK', default => 'ERR' };

// read json file
$data = json_decode(file_get_contents('file.json'), true);
```

## CLI commands

```
php -v
php -a
composer install
vendor/bin/phpunit
vendor/bin/phpstan analyse src --level=7
```

---

# Further Reading

- Official PHP Manual — language reference and standard library (php.net)
- Composer docs — dependency management
- PSR/FIG standards (PSR-4, PSR-12, PSR-7, PSR-3)
- PHPUnit, PHPStan, Psalm docs

---

> **Done.** This single-file pocketbook is intentionally compact — keep it open while coding. Happy hacking!

